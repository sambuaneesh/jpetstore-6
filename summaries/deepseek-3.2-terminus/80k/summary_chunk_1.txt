# MyBatis JPetStore 6 - Architectural Summary

## Overview
MyBatis JPetStore 6 is a complete web application built on **MyBatis 3**, **Spring 5**, and **Stripes** framework. It's an online pet store demonstrating a typical three-tier Java web application architecture.

## Core Components and Responsibilities

### Domain Models
- **Account**: User account information and preferences
- **Cart/CartItem**: Shopping cart functionality with quantity management
- **Category/Product/Item**: Catalog hierarchy structure
- **Order/LineItem**: Order management and line items
- **Sequence**: ID generation for orders

### Service Layer
- **AccountService**: User registration, authentication, profile management
- **CatalogService**: Product catalog browsing, searching, inventory checks
- **OrderService**: Order processing, inventory updates, sequence generation

### Data Access Layer
- **AccountMapper**: User account CRUD operations
- **CategoryMapper/ProductMapper/ItemMapper**: Catalog data access
- **OrderMapper/LineItemMapper**: Order data management
- **SequenceMapper**: Sequence number generation

### Web Layer (ActionBeans)
- **AccountActionBean**: User authentication, registration, profile management
- **CartActionBean**: Shopping cart operations
- **CatalogActionBean**: Product browsing and searching
- **OrderActionBean**: Order creation and management

## API Endpoints and Interfaces

### Web Endpoints (Stripes Actions)
- `/actions/Account.action` - User authentication and account management
- `/actions/Cart.action` - Shopping cart operations
- `/actions/Catalog.action` - Product catalog browsing
- `/actions/Order.action` - Order processing

### Service Interfaces
- **AccountService**: `getAccount()`, `insertAccount()`, `updateAccount()`
- **CatalogService**: `getCategoryList()`, `searchProductList()`, `isItemInStock()`
- **OrderService**: `insertOrder()`, `getOrder()`, `getOrdersByUsername()`

## Database Schema and Data Models

### Core Tables
- **ACCOUNT**: User profiles (`userid`, `email`, `firstname`, `lastname`, address fields)
- **PROFILE**: User preferences (`langpref`, `favcategory`, `mylistopt`, `banneropt`)
- **SIGNON**: Authentication (`username`, `password`)
- **CATEGORY/PRODUCT/ITEM**: Catalog hierarchy
- **ORDERS/ORDERSTATUS/LINEITEM**: Order management
- **INVENTORY**: Stock quantities
- **SUPPLIER**: Vendor information
- **BANNERDATA**: UI customization
- **SEQUENCE**: ID generation

### Key Relationships
- Category → Product (one-to-many)
- Product → Item (one-to-many)
- Account → Orders (one-to-many)
- Order → LineItem (one-to-many)

## Service Dependencies and Communication Patterns

### Internal Dependencies
```
Web Actions → Services → Mappers → Database
     ↓
   Session
   (Cart, Account state)
```

### Transaction Boundaries
- **AccountService**: Transactional for account creation/updates
- **OrderService**: Transactional for order processing with inventory updates

### Session Management
- **@SessionScope** used for ActionBeans
- Shopping cart maintained in HTTP session
- User authentication state in session

## Key Business Logic and Algorithms

### Shopping Cart Management
- **Cart**: Thread-safe cart implementation using synchronized maps
- **Price Calculation**: BigDecimal for precise monetary calculations
- **Inventory Validation**: Real-time stock checks before cart operations

### Order Processing
```java
// Sequence-based order ID generation
public int getNextId(String name) {
    Sequence sequence = sequenceMapper.getSequence(new Sequence(name, -1));
    sequenceMapper.updateSequence(new Sequence(name, sequence.getNextId() + 1));
    return sequence.getNextId();
}
```

### Search Algorithm
```java
// Multi-keyword search with wildcards
public List<Product> searchProductList(String keywords) {
    List<Product> products = new ArrayList<>();
    for (String keyword : keywords.split("\\s+")) {
        products.addAll(productMapper.searchProductList("%" + keyword.toLowerCase() + "%"));
    }
    return products;
}
```

## Configuration and Deployment

### Framework Configuration
- **Spring**: Dependency injection, transaction management
- **MyBatis**: ORM with XML mapper configurations
- **Stripes**: MVC framework with Spring integration

### Build and Deployment
- **Maven-based** build system with wrapper
- **WAR packaging** for application servers
- **Docker support** via Dockerfile and docker-compose
- **Multiple profiles** for different application servers (Tomcat, Jetty, WildFly, etc.)

### Database Configuration
- **HSQLDB** embedded database for development
- **Spring JDBC** for database initialization
- **MyBatis Spring** integration for mapper scanning

## Architectural Patterns

### Design Patterns
- **MVC**: Stripes ActionBeans (Controller), JSPs (View), Domain objects (Model)
- **Data Mapper**: MyBatis for data access abstraction
- **Dependency Injection**: Spring IoC container
- **Session Façade**: ActionBeans as session facades

### Caching Strategy
- **MyBatis L2 Cache**: Enabled in mapper XML files
- **Session Cache**: Shopping cart and user data in HTTP session

### Transaction Management
- **Declarative Transactions**: Spring `@Transactional` annotations
- **ACID Compliance**: Order processing with inventory updates

## Technology Stack

### Core Frameworks
- **Spring 5.3.39** (Context, JDBC, Web)
- **MyBatis 3.5.19** with MyBatis-Spring 3.0.5
- **Stripes 1.6.0** MVC framework
- **HSQLDB 2.7.4** database

### Web Technologies
- **JSP 2.3** with JSTL
- **Servlet 4.0** API
- **HTML/CSS** frontend

### Testing
- **JUnit 5** with Mockito
- **Selenide** for UI testing
- **Spring Test** for integration testing

## Microservice Decomposition Analysis Points

### Potential Service Boundaries
1. **User Service**: Account management, authentication
2. **Catalog Service**: Product browsing, searching, inventory
3. **Order Service**: Order processing, fulfillment
4. **Cart Service**: Shopping cart management

### Data Consistency Challenges
- Order processing requires atomic updates across inventory and order tables
- Shopping cart data currently session-bound
- User preferences span multiple tables

### Integration Points
- External payment gateway (currently mocked)
- Inventory management system
- Shipping/courier integration

This architecture represents a well-structured monolithic application that could be decomposed into microservices based on business capabilities (User, Catalog, Order, Cart domains).