Comprehensive Architectural Summary — MyBatis JPetStore 6 (Merged)

Overview and System Context
- Monolithic Java EE web application implementing an online pet store with catalog browsing, shopping cart, user account management, and checkout.
- Layered architecture:
  - Presentation: Stripes ActionBeans (action-based MVC), JSP, JSTL.
  - Service/Business: Spring-managed @Service beans, transaction boundaries.
  - Persistence: MyBatis 3 mapper interfaces with XML SQL mappings (via MyBatis-Spring).
  - Domain: Plain Java POJOs.
- Storage: Embedded HSQLDB initialized on startup via Spring scripts (schema and seed data). DB is ephemeral for demo/dev.
- Packaging and runtime: Maven-built WAR deployed to a servlet container (Tomcat default via cargo plugin) or run in Docker.

Key Frameworks, Libraries, Versions, and Patterns
- Web MVC: Stripes 1.6.0 ActionBeans, JSP, JSTL; Stripes tags.
- Spring Framework:
  - DI and transactions (@Service, @Transactional).
  - Context loader via web.xml; DataSourceTransactionManager.
- Persistence: MyBatis 3.5.19 with MyBatis-Spring 3.0.5. Type aliases set to org.mybatis.jpetstore.domain.
- Database: HSQLDB 2.7.x, embedded via Spring’s EmbeddedDatabase; production-ready to use any JDBC DataSource.
- Caching: MyBatis second-level cache enabled on each mapper (<cache/> in XML).
- Logging: SLF4J (simple).
- Build: Maven (war), Java 17 target; cargo-maven3-plugin for container lifecycle.
- Servlet API and compatibility:
  - Project builds against jakarta.servlet-api 4.0.4 (provided) with a servlet 4.0 web-app descriptor.
  - The Stripes configuration remains compatible with servlet 2.5/JSP 2.1 patterns; CI targets multiple servlet containers (Tomcat, TomEE, WildFly, Liberty EE8, Jetty, GlassFish 5, Resin).
- Docker: OpenJDK 21 base image builds and runs the app.
- Architectural patterns:
  - Layered architecture (Presentation → Service → Persistence → DB).
  - Repository/DAO via MyBatis mapper interfaces.
  - Action-based controllers with session-scoped conversational state (cart, account, order).
  - Sequence-table pattern for order ID generation.

Build, Packaging, Deployment, and CI
- Maven:
  - Packaging WAR; finalName: jpetstore.
  - Dependencies include Spring Context/JDBC 6.2.x, spring-web 5.3.39 (held until a full jakarta upgrade), Stripes, JSTL, HSQLDB, SLF4J.
  - Test deps: JUnit 5, Mockito, AssertJ, Spring Test, Selenide, HtmlUnit.
  - Cargo plugin profiles for multiple servers; Tomcat 9 default on port 8080.
- CI/CD:
  - GitHub Actions pipelines for build/test across JDK 17/21/24/25-ea and multiple OSs.
  - CodeQL and SonarCloud integration; site to gh-pages; artifacts to Sonatype (for this example repo).
- Docker:
  - Dockerfile: FROM openjdk:21; uses Maven Wrapper; builds WAR and runs cargo:run with Tomcat 9 profile.
  - docker-compose exposes port 8080; restart always.
- Run URL: http://localhost:8080/jpetstore/ (index.html → “Enter the Store” → /actions/Catalog.action).

Domain Models (org.mybatis.jpetstore.domain)
- Account: username, password, email, firstName, lastName, status, address1, address2, city, state, zip, country, phone, languagePreference, favouriteCategoryId, listOption (boolean), bannerOption (boolean), bannerName. First/last name setters have validation annotations.
- Category: categoryId, name, description.
- Product: productId, categoryId, name, description.
- Item: itemId, productId, listPrice (BigDecimal), unitCost (BigDecimal), supplierId, status, attribute1..attribute5 (nullable), Product product, quantity (hydrated from inventory on enrich).
- Cart and CartItem:
  - Cart: synchronized map + list of items; add/remove/update/increment; subtotal calculation; iterators over cart items; containsItemId; setQuantityByItemId; incrementQuantityByItemId.
  - CartItem: Item item, boolean inStock, int quantity, BigDecimal total (recomputed on changes).
- Order: orderId, orderDate, username, cardType, creditCard, expiryDate, courier, locale, totalPrice, billing and shipping name/address fields, status, List<LineItem> lineItems.
  - initOrder(Account, Cart): copies account details to both ship/bill; sets defaults (creditCard="999 9999 9999 9999", cardType="Visa", expiryDate="12/03", courier="UPS", locale="CA", status="P"); computes totalPrice from cart; transforms CartItems into numbered LineItems.
- LineItem: orderId, lineNumber, itemId, quantity, unitPrice (BigDecimal), Item item; total computed.
- Sequence: name, nextId (int) for ID generation.

Persistence Layer (org.mybatis.jpetstore.mapper + XML in resources/org/mybatis/jpetstore/mapper)
- AccountMapper
  - Methods: getAccountByUsername(String), getAccountByUsernameAndPassword(String,String), insertAccount(Account), insertProfile(Account), insertSignon(Account), updateAccount(Account), updateProfile(Account), updateSignon(Account).
  - SQL:
    - SELECT joins ACCOUNT, PROFILE, SIGNON, BANNERDATA; PROFILE.MYLISTOPT/BANNEROPT mapped to booleans; bannerName from BANNERDATA via favouriteCategory.
    - INSERT/UPDATE into ACCOUNT, PROFILE, SIGNON with explicit JDBC types.
  - <cache/> enabled.
- CategoryMapper
  - Methods: getCategoryList(), getCategory(String categoryId).
  - SQL: SELECT mapping catid → categoryId, descn → description.
  - <cache/> enabled.
- ProductMapper
  - Methods: getProductListByCategory(String categoryId), getProduct(String productId), searchProductList(String keywordPattern).
  - SQL: SELECTs mapping descn → description, category → categoryId; search uses lower(name) like pattern “%kw%”.
  - <cache/> enabled.
- ItemMapper
  - Methods: getItemListByProduct(String productId), getItem(String itemId), getInventoryQuantity(String itemId), updateInventoryQuantity(Map{itemId, increment}).
  - SQL:
    - getItemListByProduct: join ITEM I with PRODUCT P; nested result mapping populates Item.product.*.
    - getItem: join ITEM I, INVENTORY V, PRODUCT P; maps INVENTORY.QTY → Item.quantity.
    - updateInventoryQuantity: UPDATE INVENTORY SET QTY = QTY - #{increment}; note: increment is positive to subtract.
  - <cache/> enabled.
- OrderMapper
  - Methods: getOrdersByUsername(String username), getOrder(int orderId), insertOrder(Order), insertOrderStatus(Order).
  - SQL:
    - getOrder/getOrdersByUsername: join ORDERS with ORDERSTATUS; maps order header fields including billing/shipping; type aliases used for domain mapping.
    - insertOrder: full header insert.
    - insertOrderStatus: inserts status row with LINENUM = ORDERID and timestamp; status value stored.
  - <cache/> enabled.
- LineItemMapper
  - Methods: getLineItemsByOrderId(int orderId), insertLineItem(LineItem).
  - SQL: straightforward SELECT and INSERT; <cache/> enabled.
- SequenceMapper
  - Methods: getSequence(Sequence), updateSequence(Sequence).
  - SQL: SELECT by name; UPDATE nextid; <cache/> enabled.

Service Layer (org.mybatis.jpetstore.service, Spring @Service beans)
- AccountService
  - APIs: getAccount(String username), getAccount(String username, String password), insertAccount(Account), updateAccount(Account).
  - Behavior:
    - insertAccount: insert ACCOUNT, PROFILE, SIGNON in one transaction.
    - updateAccount: update ACCOUNT, PROFILE; conditionally update SIGNON if password present (non-empty).
  - Dependencies: AccountMapper.
- CatalogService
  - APIs: getCategoryList(), getCategory(String categoryId), getProduct(String productId), getProductListByCategory(String categoryId), getItemListByProduct(String productId), getItem(String itemId), isItemInStock(String itemId), searchProductList(String keywords).
  - Behavior: searchProductList splits keywords on whitespace, runs lower(name) LIKE “%kw%” per token, concatenates results (no deduplication).
  - Dependencies: CategoryMapper, ProductMapper, ItemMapper.
- OrderService
  - APIs: insertOrder(Order order) [@Transactional], getOrder(int orderId) [enriches with items and availability], getOrdersByUsername(String username), getNextId(String name).
  - insertOrder Behavior:
    - orderId = getNextId("ordernum").
    - For each line item: decrement INVENTORY by quantity via ItemMapper.updateInventoryQuantity.
    - Insert order header and initial status via OrderMapper.
    - Assign orderId to each LineItem and insert via LineItemMapper.
    - Entire workflow transactional; rollback on failure.
  - getOrder Behavior:
    - Load order and line items.
    - For each line: load Item (with nested Product) and current inventory quantity; set Item.quantity and attach to LineItem.
  - getNextId Behavior:
    - Fetch sequence by name; if null, throw RuntimeException.
    - Return current nextId and atomically update to nextId + 1.
  - Dependencies: ItemMapper, OrderMapper, LineItemMapper, SequenceMapper.

Presentation Layer (org.mybatis.jpetstore.web.actions, Stripes ActionBeans)
- Common patterns:
  - All ActionBeans are session-scoped to maintain conversational state (account, cart, order).
  - Stripes stores ActionBeans in session under keys like "/actions/Account.action".
  - The application also stores "accountBean" on successful login for banner/my list rendering.
  - Base class AbstractActionBean provides ActionBeanContext and messaging helpers; common error page path.
- AccountActionBean (/actions/Account.action)
  - Dependencies: @SpringBean AccountService, CatalogService.
  - State: Account account, List<Product> myList (favorite category list), boolean authenticated, username, password.
  - Static lists for registration/edit: languages ["english","japanese"]; categories ["FISH","DOGS","REPTILES","CATS","BIRDS"].
  - Views: NEW_ACCOUNT (/WEB-INF/jsp/account/NewAccountForm.jsp), EDIT_ACCOUNT (/WEB-INF/jsp/account/EditAccountForm.jsp), SIGNON (/WEB-INF/jsp/account/SignonForm.jsp).
  - Events:
    - @DefaultHandler signonForm → SIGNON.
    - signon: authenticate; on success, clear password, populate myList from favouriteCategory, set authenticated=true, put "accountBean" in session; redirect to CatalogActionBean main. On failure, add message and forward to SIGNON.
    - signoff: invalidate session, clear state; redirect to CatalogActionBean main.
    - newAccountForm → NEW_ACCOUNT.
    - newAccount: insert, reload account, populate myList, authenticated=true; redirect main.
    - editAccountForm → EDIT_ACCOUNT.
    - editAccount: update account; reload and refresh myList; redirect main.
  - Validation: username/password required for signon; account.* required as per annotations.
- CatalogActionBean (/actions/Catalog.action)
  - Dependency: @SpringBean CatalogService.
  - State: keyword, categoryId, productId, itemId; and loaded category, product, item; lists categoryList/productList/itemList.
  - Views: MAIN (/WEB-INF/jsp/catalog/Main.jsp), VIEW_CATEGORY, VIEW_PRODUCT, VIEW_ITEM, SEARCH_PRODUCTS.
  - Events:
    - @DefaultHandler viewMain → MAIN.
    - viewCategory: requires categoryId; loads productList and category; forward VIEW_CATEGORY.
    - viewProduct: requires productId; loads itemList and product; forward VIEW_PRODUCT.
    - viewItem: requires itemId; loads item and product; forward VIEW_ITEM.
    - searchProducts: non-empty keyword; perform search; forward SEARCH_PRODUCTS; else error.
  - Also used by cart to check stock and item details during add operations.
- CartActionBean (/actions/Cart.action)
  - Dependency: @SpringBean CatalogService.
  - State: Cart cart, String workingItemId.
  - Views: VIEW_CART (/WEB-INF/jsp/cart/Cart.jsp), CHECK_OUT (/WEB-INF/jsp/cart/Checkout.jsp).
  - Events:
    - viewCart → VIEW_CART.
    - checkOut → CHECK_OUT.
    - addItemToCart: if already in cart, increment; else load item and stock, add to cart; forward VIEW_CART.
    - removeItemFromCart: remove by workingItemId; on null, forward ERROR; else VIEW_CART.
    - updateCartQuantities: iterate cart items; read quantity from param named by itemId; set quantities; remove if <1; forward VIEW_CART.
- OrderActionBean (/actions/Order.action)
  - Dependency: @SpringBean OrderService.
  - State: Order order, boolean shippingAddressRequired, boolean confirmed, List<Order> orderList.
  - Views: LIST_ORDERS, NEW_ORDER, SHIPPING, CONFIRM_ORDER, VIEW_ORDER.
  - Events:
    - listOrders: obtain AccountActionBean from session; load orderList by username; forward LIST_ORDERS.
    - newOrderForm: fetch accountBean and cartBean from session; if not authenticated, message and forward to AccountActionBean; else order.initOrder(account, cart); forward NEW_ORDER.
    - newOrder: multi-step flow:
      - If shippingAddressRequired: clear flag; forward SHIPPING (address form).
      - Else if not confirmed: forward CONFIRM_ORDER.
      - Else if order != null: OrderService.insertOrder(order); clear CartActionBean; add message; forward VIEW_ORDER; else error.
    - viewOrder: load order by orderId; ensure logged-in username matches order.username; forward VIEW_ORDER or ERROR.

View Layer (JSPs under /WEB-INF/jsp and common fragments)
- Common:
  - IncludeTop.jsp: taglib decls; header, nav, search form, quick links.
  - IncludeBottom.jsp: footer, banner (if account.bannerOption), closing HTML.
  - Error.jsp: includes header/footer and message list.
- Feature views:
  - Catalog: Main.jsp, Category.jsp, Product.jsp, Item.jsp (stock status displayed from INVENTORY).
  - Cart: Cart.jsp (update quantities, remove, subtotal), Checkout.jsp (summary prior to order forms).
  - Account: SignonForm.jsp (defaults shown in UI; integration tests use j2ee/j2ee), NewAccountForm.jsp, EditAccountForm.jsp.
  - Order: NewOrderForm.jsp (billing/payment), ShippingForm.jsp (optional shipping), ConfirmOrder.jsp, ViewOrder.jsp, ListOrders.jsp.
- JSTL and Stripes tags: <stripes:link>, <stripes:form>, <stripes:text>, <stripes:submit>, etc.

HTTP Endpoints, Parameters, and UI Contracts
- Dispatcher: Stripes DispatcherServlet mapped to *.action; StripesFilter intercepts for DI and routing.
- Action package discovery: org.mybatis.jpetstore.web.
- Entry:
  - /jpetstore/index.html → link to /actions/Catalog.action (viewMain).
  - /jpetstore/help.html static.
- Catalog:
  - GET /actions/Catalog.action (viewMain).
  - /actions/Catalog.action?viewCategory&categoryId={catId}.
  - /actions/Catalog.action?viewProduct&productId={prodId}.
  - /actions/Catalog.action?viewItem&itemId={itemId}.
  - /actions/Catalog.action?searchProducts with form field keyword and submit name="searchProducts".
- Account:
  - /actions/Account.action?signonForm; form fields username, password; submit name="signon".
  - /actions/Account.action?signoff.
  - /actions/Account.action?newAccountForm; registration fields:
    - username, password, repeatedPassword
    - account.firstName, account.lastName, account.email, account.phone
    - account.address1, account.address2, account.city, account.state, account.zip, account.country
    - account.languagePreference (select), account.favouriteCategoryId (select, e.g., CATS)
    - account.listOption (checkbox), account.bannerOption (checkbox)
    - submit name="newAccount".
  - /actions/Account.action?editAccountForm; edit fields include account.phone; submit name="editAccount".
- Cart:
  - /actions/Cart.action?viewCart.
  - /actions/Cart.action?addItemToCart&workingItemId={itemId}.
  - /actions/Cart.action?removeItemFromCart&workingItemId={itemId}.
  - /actions/Cart.action?updateCartQuantities (form inputs named exactly by itemId, e.g., name="EST-20").
  - /actions/Cart.action?checkOut.
- Order:
  - /actions/Order.action?listOrders.
  - /actions/Order.action?newOrderForm.
  - /actions/Order.action?newOrder (multi-step; checkbox shippingAddressRequired, and a Confirm link/button “Confirm”).
  - /actions/Order.action?viewOrder&orderId={id}.

Database Schema and Relationships (HSQLDB)
- Core tables (names/columns as used in SQL and mappings):
  - SIGNON(username PK, password).
  - ACCOUNT(userid PK, email, firstname, lastname, status, addr1, addr2, city, state, zip, country, phone).
  - PROFILE(userid PK, langpref, favcategory, mylistopt int, banneropt int).
  - BANNERDATA(favcategory PK, bannername).
  - CATEGORY(catid PK, name, descn).
  - PRODUCT(productid PK, category FK → CATEGORY.catid, name, descn). Indices: PRODUCTCAT (category), PRODUCTNAME (name).
  - ITEM(itemid PK, productid FK → PRODUCT.productid, listprice, unitcost, supplier FK → SUPPLIER.suppid, status, attr1..attr5). Index: ITEMPROD (productid).
  - INVENTORY(itemid PK, qty).
  - SUPPLIER(suppid PK, name, status, addr1, addr2, city, state, zip, phone).
  - ORDERS(orderid PK, userid, orderdate, shipaddr1/2, shipcity, shipstate, shipzip, shipcountry, billaddr1/2, billcity, billstate, billzip, billcountry, courier, totalprice, billtofirstname, billtolastname, shiptofirstname, shiptolastname, creditcard, exprdate, cardtype, locale).
  - ORDERSTATUS(orderid, linenum PK composite, timestamp, status) — initial status LINENUM often equals ORDERID.
  - LINEITEM(orderid, linenum PK composite, itemid, quantity, unitprice).
  - SEQUENCE(name PK, nextid).
- Relationships:
  - ACCOUNT.userid ties to SIGNON.username and PROFILE.userid (conceptual).
  - PROFILE.favcategory is a string matching CATEGORY/BANNERDATA catid (not necessarily FK-enforced).
  - PRODUCT.category → CATEGORY.catid.
  - ITEM.productid → PRODUCT.productid; ITEM.supplier → SUPPLIER.suppid.
  - INVENTORY.itemid ↔ ITEM.itemid (conceptual).
  - ORDERS.userid → ACCOUNT.userid (not enforced in schema).
  - ORDERSTATUS and LINEITEM keyed by (orderid, linenum).
  - SEQUENCE provides mutable counters for ID generation.
- Seed data:
  - schema.sql and dataload.sql: define DDL and insert baseline data (users, profiles, categories/products/items, inventory with ample quantities, sequence 'ordernum' starting at ~1000). Some variants show different default passwords for the “j2ee” user; UI tests and default login prompts typically use j2ee/j2ee.
  - data.sql is an alternate combined schema+data initializer.

Transactions, Caching, and State Management
- Transactions:
  - Spring DataSourceTransactionManager; @Transactional on service methods (notably OrderService.insertOrder and read flows) covers multiple mapper calls atomically.
  - Inventory decrements and order writes occur in a single transaction to ensure consistency in the monolith.
- Caching:
  - MyBatis second-level cache per mapper (<cache/>) enabled with default settings.
  - Read queries often join to eliminate N+1 (e.g., Item with Product).
- Session State:
  - ActionBeans are session-scoped, holding AccountActionBean (account and auth), CartActionBean (cart contents), and OrderActionBean (in-progress order flow).
  - Additional session attributes: Stripes stores beans under path keys (“/actions/Account.action”, etc.); an “accountBean” attribute is set on signon for display concerns (banner and quick list).
- Security:
  - Basic auth: username/password lookup against SIGNON table; passwords stored in plaintext; no hashing, roles, or CSRF protection.

Key Business Logic and Algorithms
- Authentication and Account Management:
  - Login via SIGNON join query; sets authenticated state in session; banner preferences and favorite category pre-load.
  - Account insert/update spans ACCOUNT, PROFILE; SIGNON insert/update conditionally based on password presence.
- Catalog Search:
  - Splits keyword string on whitespace; for each token, executes case-insensitive LIKE on product name (“%kw%”); concatenates results (no deduplication logic).
- Cart:
  - Add item: increments if present else fetches current item and inventory status; maintains inStock flag.
  - Update quantities: input names equal itemIds; invalid or <1 quantities remove the item.
  - Subtotal: sum of line items’ listPrice * quantity.
- Order Processing:
  - Build order (initOrder): copy account info; set defaults (UPS courier, Visa card type, locale CA); derive total from cart; transform cart to line items.
  - Place order (insertOrder): compute orderId via Sequence; decrement inventory per line; insert order header and initial status (ORDERSTATUS LINENUM equals ORDERID); insert each line item; all in one transaction.
  - View order: enrich line items with current Item (and Product) and current inventory quantity for availability display.
- Sequence Management:
  - getNextId(name): select Sequence; exception if not found; returns current nextId and updates to nextId+1 (atomic in transaction).

Configuration Details
- web.xml:
  - StripesFilter: net.sourceforge.stripes.controller.StripesFilter
    - Init params:
      - ActionResolver.Packages = org.mybatis.jpetstore.web
      - Either Interceptor.Classes = net.sourceforge.stripes.integration.spring.SpringInterceptor or Extension.Packages = net.sourceforge.stripes.integration.spring (to integrate Spring DI into ActionBeans; both patterns are seen in use).
  - Stripes DispatcherServlet: net.sourceforge.stripes.controller.DispatcherServlet mapped to *.action.
  - Spring ContextLoaderListener to initialize applicationContext.xml.
  - JSTL resource bundle: StripesResources.properties.
- Spring applicationContext.xml:
  - <context:component-scan base-package="org.mybatis.jpetstore.service"/>.
  - <jdbc:embedded-database id="dataSource" type="HSQL"> with scripts classpath:database/jpetstore-hsqldb-schema.sql and classpath:database/jpetstore-hsqldb-dataload.sql.
  - <bean id="transactionManager" class="...DataSourceTransactionManager" dataSource-ref="dataSource"/>.
  - <bean id="sqlSessionFactory" class="...SqlSessionFactoryBean" dataSource-ref="dataSource" typeAliasesPackage="org.mybatis.jpetstore.domain"/>.
  - <mybatis:scan base-package="org.mybatis.jpetstore.mapper"/>.
  - <tx:annotation-driven/> enabled.
- Tests (MapperTestContext.java):
  - Programmatic Spring config to mirror applicationContext; EmbeddedDatabase HSQL; TransactionManager; SqlSessionFactoryBean; @MapperScan("org.mybatis.jpetstore.mapper").

Exposed Interfaces (for decomposition mapping)
- Service APIs (called by web layer):
  - AccountService: getAccount(String), getAccount(String, String), insertAccount(Account), updateAccount(Account).
  - CatalogService: getCategoryList(), getCategory(String), getProduct(String), getProductListByCategory(String), searchProductList(String), getItemListByProduct(String), getItem(String), isItemInStock(String).
  - OrderService: insertOrder(Order), getOrder(int), getOrdersByUsername(String), getNextId(String).
- Persistence APIs (MyBatis mappers; represent DB operations):
  - AccountMapper: getAccountByUsername, getAccountByUsernameAndPassword, insertAccount, insertProfile, insertSignon, updateAccount, updateProfile, updateSignon.
  - CategoryMapper: getCategoryList, getCategory.
  - ProductMapper: getProductListByCategory, getProduct, searchProductList.
  - ItemMapper: getItemListByProduct, getItem, getInventoryQuantity, updateInventoryQuantity.
  - OrderMapper: getOrdersByUsername, getOrder, insertOrder, insertOrderStatus.
  - LineItemMapper: getLineItemsByOrderId, insertLineItem.
  - SequenceMapper: getSequence, updateSequence.

Testing and Quality
- Unit tests:
  - Domain: CartTest, OrderTest.
  - Services: AccountServiceTest, CatalogServiceTest, OrderServiceTest (Mockito).
  - Persistence: AccountMapperTest, CategoryMapperTest, ItemMapperTest, LineItemMapperTest, OrderMapperTest, ProductMapperTest, SequenceMapperTest against embedded HSQL with real SQL.
- Integration/UI tests:
  - ScreenTransitionIT with Selenide (headless Chrome) exercises login, browse, cart, checkout, account update, order history.

Operational Notes and Constraints
- Default DB is in-memory; data resets on restart.
- Passwords are stored in plaintext; no password hashing, CSRF protection, or role-based auth.
- MyBatis second-level caches are enabled, but inventory updates follow a simple decrement without explicit locking beyond DB isolation.
- Some DTO/view concerns (bannerName) depend on joining BANNERDATA via favouriteCategoryId.

Couplings and Boundaries (for microservice decomposition)
- Data ownership domains:
  - Account: owns ACCOUNT, PROFILE, SIGNON (and consults BANNERDATA for display).
  - Catalog: owns CATEGORY, PRODUCT, ITEM; INVENTORY is part of catalog/inventory responsibilities.
  - Order: owns ORDERS, ORDERSTATUS, LINEITEM; uses SEQUENCE for IDs.
- Cross-domain couplings:
  - OrderService decrements INVENTORY (ItemMapper) during order placement (cross-domain mutation).
  - OrderService enriches order lines with Item/Product and current inventory on reads (cross-service query in a decomposed system).
  - Global Sequence table used by OrderService (shared mutable state).
- Transaction scope:
  - Monolith executes orders + inventory adjustment in a single DB transaction. In microservices, requires eventual consistency (e.g., saga/outbox, reservation/compensation patterns).
- Decomposition considerations:
  - Candidate services: Account Service, Catalog/Inventory Service, Order Service, and an internal ID/Sequence service (or move to per-service ID generation such as UUID or database-specific sequences owned by the Order service).
  - For inventory coupling:
    - Reservation pattern during checkout (reserve stock then confirm on order placement or release on failure).
    - Outbox pattern for order-created events and inventory-updated events.
  - Query composition:
    - For Order detail views, consider denormalized projections or API composition from Catalog for item details.
  - Caching and read models:
    - Maintain read-optimized projections for common UI queries (e.g., Item with Product summary).
- Security and hardening:
  - Introduce password hashing, session security, CSRF tokens.
  - Consider API gateway or BFF for UI if moving to services; avoid exposing internal DB schemas.

Notable Implementation Details and Nuances
- Item queries commonly join to Product to hydrate nested structures; Order.getOrder rehydrates Item and inventory for availability display.
- Inventory decrement uses positive increment to subtract (QTY = QTY - increment) — be careful with concurrency if porting.
- Category “favorites” drive both UI banner selection (via BANNERDATA) and quick-list display on main page.
- Stripes session keys: Stripes stores ActionBeans under their URL bindings (e.g., "/actions/Account.action"); application also uses “accountBean” for UI needs.
- Stripes-Spring integration is configured either via Interceptor.Classes (SpringInterceptor) or Extension.Packages pointing to net.sourceforge.stripes.integration.spring, depending on deployment configuration.

Run/Operate Summary
- Start via Maven cargo:run (Tomcat 9 profile) or Docker compose; access at http://localhost:8080/jpetstore/.
- Main flows:
  - Browse categories/products/items; add to cart; update quantities.
  - Sign in/up; edit account.
  - Proceed to checkout: enter billing/shipping as needed; confirm; view past orders.

This consolidated summary preserves component names, APIs, dependencies, call paths, schemas, transactions, configuration, deployment/test infrastructure, endpoints and UI contracts, and the domain couplings needed for detailed microservice decomposition and migration analysis.