=== summary_chunk_1.txt ===

Architectural Summary (MyBatis JPetStore 6 — Chunk 1 of 2)

Overview
- Monolithic Java EE web app implementing an online pet store (catalog browsing, cart, account, checkout).
- Layered architecture: Web (Stripes ActionBeans + JSP), Service (Spring-managed services), Persistence (MyBatis Mappers + XML), Domain model (POJOs).
- Storage: Embedded HSQLDB initialized at startup via Spring.
- Packaged as a WAR; runs on servlet container (Tomcat by default) or via Docker.

Key Frameworks, Libraries, and Patterns
- Web MVC: Stripes (Action-based MVC), JSP, JSTL.
- Dependency Injection & Transactions: Spring Framework (Context, JDBC, @Transactional).
- Persistence: MyBatis 3 (SQL mappers + XML), MyBatis-Spring.
- DB: HSQLDB (embedded for demo).
- Caching: MyBatis second-level cache enabled per mapper via <cache/>.
- Logging: SLF4J (simple).
- Packaging/Build: Maven (war); cargo-maven3-plugin for container management.
- Docker: OpenJDK 21 base image builds and runs app.
- Architectural patterns:
  - Layered architecture (Presentation -> Service -> Persistence -> DB).
  - Repository/DAO via MyBatis mapper interfaces.
  - Action-based controllers (Stripes ActionBeans).
  - Session-scoped controllers for conversational state (cart, account, order).
  - Sequence table pattern for ID generation.

Components and Responsibilities

Domain Model (POJOs)
- Account: User profile, contact, preferences, options, banner settings. Fields include username, password, email, addresses, phone, favouriteCategoryId, languagePreference, listOption, bannerOption, bannerName; validation annotations on first/last name setters.
- Cart: Holds cart items in a synchronized map + list; operations for add/remove/update/increment; subtotal calculation.
- CartItem: Item + quantity + inStock + computed total; calculateTotal on item/quantity changes.
- Category: categoryId, name, description.
- Product: productId, categoryId, name, description.
- Item: itemId, productId, listPrice, unitCost, supplierId, status, attributes 1–5, Product, quantity; toString combines item and product.
- LineItem: orderId, lineNumber, quantity, itemId, unitPrice, Item, total; constructors from CartItem; calculate total.
- Order: Comprehensive order header (billing/shipping, totals, payment, courier, locale, status) and lineItems; initOrder(account, cart) populates fields and derives totals.
- Sequence: name, nextId (for ID generation).

Persistence Layer (MyBatis Mapper Interfaces + SQL XML)
- AccountMapper
  - Methods: getAccountByUsername, getAccountByUsernameAndPassword, insertAccount, insertProfile, insertSignon, updateAccount, updateProfile, updateSignon.
  - SQL (AccountMapper.xml):
    - SELECT joins ACCOUNT, PROFILE, SIGNON, BANNERDATA; maps PROFILE.MYLISTOPT/BANNEROPT to booleans; requires BANNERDATA for bannerName.
    - INSERT/UPDATE into ACCOUNT/PROFILE/SIGNON with appropriate mappings and JDBC types.
    - <cache/> enabled.

- CategoryMapper
  - Methods: getCategoryList, getCategory.
  - SQL (CategoryMapper.xml): straightforward SELECTs mapping catid->categoryId, descn->description; <cache/> enabled.

- ProductMapper
  - Methods: getProductListByCategory, getProduct, searchProductList.
  - SQL (ProductMapper.xml): SELECTs mapping descn->description, category->categoryId; search uses lower(name) like pattern; <cache/> enabled.

- ItemMapper
  - Methods: updateInventoryQuantity(Map{itemId, increment}), getInventoryQuantity(itemId), getItemListByProduct(productId), getItem(itemId).
  - SQL (ItemMapper.xml):
    - getItemListByProduct: join ITEM I, PRODUCT P; nested mappings into Item.product.*.
    - getItem: join ITEM I, INVENTORY V, PRODUCT P; includes QTY as quantity.
    - updateInventoryQuantity: decrement INVENTORY.QTY by increment (note: uses positive increment to subtract).
    - <cache/> enabled.

- OrderMapper
  - Methods: getOrdersByUsername(username), getOrder(orderId), insertOrder(Order), insertOrderStatus(Order).
  - SQL (OrderMapper.xml):
    - getOrder/getOrdersByUsername: join ORDERS and ORDERSTATUS; maps to Order fields (billing/shipping).
    - insertOrder: writes complete order header.
    - insertOrderStatus: inserts into ORDERSTATUS with LINENUM=ORDERID (status line identity); status and timestamp stored.
    - <cache/> enabled.

- LineItemMapper
  - Methods: getLineItemsByOrderId(orderId), insertLineItem(LineItem).
  - SQL (LineItemMapper.xml): SELECT and INSERT mapping; <cache/> enabled.

- SequenceMapper
  - Methods: getSequence(Sequence), updateSequence(Sequence).
  - SQL (SequenceMapper.xml): SELECT by name; UPDATE nextid; <cache/> enabled.

Service Layer (Spring @Service)
- AccountService (depends on AccountMapper)
  - getAccount(username) and getAccount(username,password).
  - insertAccount(Account): inserts into ACCOUNT, PROFILE, SIGNON (transactional).
  - updateAccount(Account): updates ACCOUNT, PROFILE, and if password present, SIGNON (transactional; conditional update for password).

- CatalogService (depends on CategoryMapper, ItemMapper, ProductMapper)
  - getCategoryList(), getCategory(categoryId).
  - getProduct(productId); getProductListByCategory(categoryId).
  - searchProductList(keywords): split on whitespace; performs lower(name) LIKE searches with %keyword%.
  - getItemListByProduct(productId), getItem(itemId).
  - isItemInStock(itemId): INVENTORY qty > 0.

- OrderService (depends on ItemMapper, OrderMapper, SequenceMapper, LineItemMapper)
  - insertOrder(Order): transactional:
    - orderId = getNextId("ordernum").
    - For each line item: decrement INVENTORY by quantity.
    - Insert order header and order status.
    - Insert line items with assigned orderId.
  - getOrder(orderId): transactional read:
    - Load order and its line items.
    - For each line item: hydrate Item (with Product and current inventory quantity) and attach to line.
  - getOrdersByUsername(username): list orders for an account.
  - getNextId(name): sequence fetch and increment; throws RuntimeException on null sequence.

Web Layer (Stripes ActionBeans, @SessionScope)
- Common
  - AbstractActionBean: base class providing access to ActionBeanContext and message helper; common ERROR JSP path.
  - All ActionBeans are session-scoped, thus hold conversational state (account, cart, order) in session.

- AccountActionBean
  - Dependencies: @SpringBean AccountService, CatalogService.
  - Views: NEW_ACCOUNT (/WEB-INF/jsp/account/NewAccountForm.jsp), EDIT_ACCOUNT (/WEB-INF/jsp/account/EditAccountForm.jsp), SIGNON (/WEB-INF/jsp/account/SignonForm.jsp).
  - Static lists: languages = ["english","japanese"]; categories = ["FISH","DOGS","REPTILES","CATS","BIRDS"].
  - State: Account account, List<Product> myList (favorites by category), boolean authenticated.
  - Endpoints/events (URL: /actions/Account.action):
    - @DefaultHandler signonForm -> forwards to SignonForm.jsp.
    - signon: fetch account by username/password; on success, null password, populate myList with favorite category, authenticated=true, put "accountBean" into session, redirect to CatalogActionBean (Main page). On failure, message and forward to SIGNON.
    - signoff: invalidate session, clear state, redirect to CatalogActionBean.
    - newAccountForm: forward to NEW_ACCOUNT.
    - newAccount: insert account; re-load account; populate myList; authenticated=true; redirect to CatalogActionBean.
    - editAccountForm: forward to EDIT_ACCOUNT.
    - editAccount: update account; re-load; update myList; redirect to CatalogActionBean.
  - Request params mapped via Stripes: username, password; account.* fields; validation annotations enforce required fields on username/password for relevant events.

- CatalogActionBean
  - Dependency: @SpringBean CatalogService.
  - Views: MAIN (/WEB-INF/jsp/catalog/Main.jsp), VIEW_CATEGORY, VIEW_PRODUCT, VIEW_ITEM, SEARCH_PRODUCTS.
  - State: keyword, categoryId, productId, itemId, and their loaded objects plus lists.
  - Endpoints/events (URL: /actions/Catalog.action):
    - @DefaultHandler viewMain -> MAIN.
    - viewCategory: requires categoryId; populates productList & category; forward to VIEW_CATEGORY.
    - viewProduct: requires productId; populates itemList & product; forward to VIEW_PRODUCT.
    - viewItem: requires itemId; loads item and product; forward to VIEW_ITEM.
    - searchProducts: requires non-empty keyword; populate productList via CatalogService.searchProductList; forward to SEARCH_PRODUCTS; else error.

- CartActionBean
  - Dependency: @SpringBean CatalogService.
  - Views: VIEW_CART (/WEB-INF/jsp/cart/Cart.jsp), CHECK_OUT (/WEB-INF/jsp/cart/Checkout.jsp).
  - State: Cart cart, String workingItemId.
  - Endpoints/events (URL: /actions/Cart.action):
    - viewCart: forwards to VIEW_CART.
    - checkOut: forwards to CHECK_OUT (summary).
    - addItemToCart: if cart contains itemId, increment; else query real-time stock and item; add to cart. Forward to VIEW_CART.
    - removeItemFromCart: remove by workingItemId; on null, forward to ERROR; else VIEW_CART.
    - updateCartQuantities: iterates all cart items; reads per-item quantity from request parameter named by itemId; sets quantities; removes if <1; forward to VIEW_CART.

- OrderActionBean
  - Dependency: @SpringBean OrderService.
  - Views: LIST_ORDERS, NEW_ORDER, SHIPPING, CONFIRM_ORDER, VIEW_ORDER.
  - State: Order order, boolean shippingAddressRequired, boolean confirmed, List<Order> orderList.
  - Endpoints/events (URL: /actions/Order.action):
    - listOrders: obtains AccountActionBean from session attribute "/actions/Account.action" (Stripes-scoped attribute); loads orderList via username; forward to LIST_ORDERS.
    - newOrderForm: gets accountBean and cartBean from session ("/actions/Account.action", "/actions/Cart.action"). If not authenticated, message and forward to AccountActionBean; else order.initOrder(account, cart); forward to NEW_ORDER; else error.
    - newOrder: multi-step:
      - If shippingAddressRequired: clear flag and forward to SHIPPING form.
      - Else if not confirmed: forward to CONFIRM_ORDER.
      - Else if order != null: OrderService.insertOrder(order); clear CartActionBean; message; forward to VIEW_ORDER. Else error.
    - viewOrder: loads order by orderId; checks if session account username equals order.username; forward to VIEW_ORDER or ERROR on mismatch.

View Layer (JSP)
- Layout JSP fragments under /WEB-INF/jsp/common:
  - IncludeTop.jsp: declares taglibs; renders header, navigation, search form; sets quick links.
  - IncludeBottom.jsp: renders footer, banner (if account bannerOption), closes HTML.
  - Error.jsp: includes header/footer and messages.
- Feature views under account, cart, catalog, order folders (as referenced above). JSTL and Stripes tags used; forms bind to ActionBeans, with <stripes:link>, <stripes:form>, <stripes:submit>, <stripes:text>, etc.

Exposed HTTP Endpoints and Interaction
- Dispatcher: StripesDispatcher servlet mapped to *.action. StripesFilter intercepts requests for dispatcher; ActionResolver.Packages = org.mybatis.jpetstore.web.
- Entry pages:
  - /jpetstore/index.html links to actions/Catalog.action (viewMain).
  - /jpetstore/help.html static help page.
- Main interaction paths:
  - Catalog: GET /actions/Catalog.action (Main), /actions/Catalog.action?viewCategory&categoryId=..., /actions/Catalog.action?viewProduct&productId=..., /actions/Catalog.action?viewItem&itemId=..., /actions/Catalog.action?searchProducts with form keyword.
  - Account: /actions/Account.action?signonForm, signon (POST form), signoff, newAccountForm, newAccount (POST form), editAccountForm, editAccount (POST form).
  - Cart: /actions/Cart.action?viewCart, addItemToCart (param workingItemId), removeItemFromCart (param workingItemId), updateCartQuantities (form fields named by itemId), checkOut.
  - Order: /actions/Order.action?listOrders, newOrderForm, newOrder (multi-step with shippingAddressRequired/confirmed flags), viewOrder (param orderId).

Database Schema and Data Model (HSQLDB)
- Tables and key columns (names as in SQL; mapping to domain fields via MyBatis result mappings):
  - SUPPLIER(suppid PK, name, status, addr1, addr2, city, state, zip, phone).
  - SIGNON(username PK, password).
  - ACCOUNT(userid PK, email, firstname, lastname, status, addr1, addr2, city, state, zip, country, phone).
  - PROFILE(userid PK, langpref, favcategory, mylistopt int, banneropt int).
  - BANNERDATA(favcategory PK, bannername).
  - CATEGORY(catid PK, name, descn).
  - PRODUCT(productid PK, category FK -> CATEGORY.catid, name, descn); indices PRODUCTCAT on category, PRODUCTNAME on name.
  - ITEM(itemid PK, productid FK -> PRODUCT.productid, listprice, unitcost, supplier FK -> SUPPLIER.suppid, status, attr1..attr5); index ITEMPROD on productid.
  - INVENTORY(itemid PK, qty).
  - ORDERS(orderid PK, userid, orderdate, shipaddr1/2, shipcity, shipstate, shipzip, shipcountry, billaddr1/2, billcity, billstate, billzip, billcountry, courier, totalprice, billtofirstname, billtolastname, shiptofirstname, shiptolastname, creditcard, exprdate, cardtype, locale).
  - ORDERSTATUS(orderid, linenum PK composite, timestamp, status).
  - LINEITEM(orderid, linenum PK composite, itemid, quantity, unitprice).
  - SEQUENCE(name PK, nextid int).
- Relationships/coupling:
  - USER: ACCOUNT.userid ties to SIGNON.username, PROFILE.userid. PROFILE.favcategory ties to CATEGORY/BANNERDATA by value (no FK to CATEGORY in DDL).
  - PRODUCT.category -> CATEGORY.catid.
  - ITEM.productid -> PRODUCT.productid; ITEM.supplier -> SUPPLIER.suppid.
  - INVENTORY.itemid -> ITEM.itemid (conceptual; not an FK in schema).
  - ORDERS.userid -> ACCOUNT.userid (not enforced).
  - ORDERSTATUS/LINEITEM keyed by (orderid, linenum).
  - SEQUENCE used for generating order numbers.
- Seed data scripts:
  - schema.sql defines tables, constraints, indices.
  - dataload.sql inserts users (j2ee/ACID), profile prefs, banner data, categories, products, suppliers, items, inventory quantities (large qty), and sequence 'ordernum' starting at 1000.
  - data.sql provides an alternate full schema+data initialization (for different use cases).

Service Dependencies and Communication Patterns
- Controllers -> Services: ActionBeans invoke Spring services via DI; session-scoped beans hold state and share via HTTP session attributes (notably Stripes also stores action beans under path keys like "/actions/Account.action").
- Services -> Persistence: Services call MyBatis mapper interfaces; MyBatis-Spring wires SqlSession proxies; @Transactional boundaries ensure atomic multi-mapper operations.
- Persistence -> DB: Synchronous SQL via MyBatis; MyBatis second-level caches per mapper; joins used to hydrate nested object graphs (e.g., Item.product.*).
- No external network calls; all intra-process calls and DB I/O.

Key Business Logic and Algorithms
- Account creation/update:
  - Insert across ACCOUNT, PROFILE, SIGNON within a single transaction.
  - Update across ACCOUNT, PROFILE; conditional SIGNON update when password supplied (non-empty).
- Authentication: Simple lookup of SIGNON by username/password; plaintext; session establishes authenticated state; stores “accountBean” for banner and my list rendering.
- Catalog search: Tokenizes keyword string by whitespace; for each token, performs case-insensitive LIKE query on product name; aggregates results (no deduplication in code).
- Cart:
  - addItem: increments existing cart item or creates new entry with real-time stock flag from INVENTORY.
  - updateCartQuantities: parses integer quantity per itemId from request params; remove item if <1.
  - subtotal: sum over cart items (listPrice * quantity).
- Order processing (multi-step):
  - Building order: initOrder copies account details to billing/shipping; sets defaults (courier UPS, locale CA, cardType Visa, mock credit card 999...); computes total from cart; transforms CartItems into LineItems with unit price and quantity.
  - Placement: obtain next orderId from SEQUENCE; decrement INVENTORY qty per item (QTY = QTY - increment); write ORDERS, ORDERSTATUS (with LINENUM=ORDERID used as status line), and LINEITEM rows; transactional.
  - View order: enrich line items with fresh Item (with current INVENTORY qty and nested Product).
- Sequence management: getSequence(name) -> updateSequence(nextId + 1) -> return previous nextId; exception if sequence missing.
- Authorization check: OrderActionBean.viewOrder confirms session account username matches order.username before showing details.

Configuration and Deployment Details
- Spring Context (WEB-INF/applicationContext.xml)
  - Embedded in-memory HSQLDB DataSource initialized with schema and dataload SQL scripts.
  - DataSourceTransactionManager bean.
  - Component-scan: org.mybatis.jpetstore.service (services).
  - @Transactional enabled (tx:annotation-driven).
  - SqlSessionFactoryBean: dataSource injection; typeAliasesPackage = org.mybatis.jpetstore.domain.
  - MyBatis mapper scanning: org.mybatis.jpetstore.mapper.
- Web App (WEB-INF/web.xml)
  - Servlet spec 4.0 web-app.
  - ContextLoaderListener for Spring.
  - StripesFilter configured with ActionResolver.Packages org.mybatis.jpetstore.web, Extension.Packages net.sourceforge.stripes.integration.spring (integrates Spring/Stripes).
  - Dispatcher servlet StripesDispatcher; mapping *.action.
  - JSTL resource bundle: StripesResources.properties.
- Maven Build (pom.xml)
  - Packaging WAR; finalName jpetstore.
  - Java 17 target (java.version=17).
  - Key deps: mybatis 3.5.19; mybatis-spring 3.0.5; Spring Context/JDBC 6.2.10; spring-web 5.3.39 (kept until jakarta upgrade); Stripes 1.6.0; Taglibs; jakarta.servlet-api 4.0.4 (provided); HSQLDB 2.7.4; SLF4J 2.0.17.
  - Test deps: JUnit 5, Mockito, AssertJ, Selenide, HtmlUnit driver, Spring Test.
  - Cargo plugin configured for multiple containers; Tomcat 9 is default profile (port 8080).
- Docker
  - Dockerfile: FROM openjdk:21; COPY project; RUN ./mvnw clean package; CMD ./mvnw cargo:run -P tomcat90.
  - docker-compose.yaml: builds local image; exposes port 8080; restart always.
- Run
  - Default URL: http://localhost:8080/jpetstore/ (index.html -> Enter the Store -> /actions/Catalog.action).
  - Profiles for other servers (TomEE, WildFly, Liberty, Jetty, GlassFish, Resin) via Maven profiles.

Interfaces Summary (for decomposition mapping)
- Service Interfaces (public methods used by web layer)
  - AccountService: getAccount(username), getAccount(username,password), insertAccount(Account), updateAccount(Account).
  - CatalogService: getCategoryList(), getCategory(categoryId), getProduct(productId), getProductListByCategory(categoryId), searchProductList(keywords), getItemListByProduct(productId), getItem(itemId), isItemInStock(itemId).
  - OrderService: insertOrder(Order), getOrder(orderId), getOrdersByUsername(username), getNextId(name).
- Persistence Interfaces (mapper methods represent DB operations)
  - AccountMapper: getAccountByUsername, getAccountByUsernameAndPassword, insert/update for ACCOUNT/PROFILE/SIGNON.
  - CategoryMapper: getCategoryList, getCategory.
  - ProductMapper: getProductListByCategory, getProduct, searchProductList.
  - ItemMapper: getItemListByProduct, getItem, getInventoryQuantity, updateInventoryQuantity.
  - OrderMapper: getOrdersByUsername, getOrder, insertOrder, insertOrderStatus.
  - LineItemMapper: getLineItemsByOrderId, insertLineItem.
  - SequenceMapper: getSequence, updateSequence.

State and Session Management
- Session-scoped ActionBeans hold user account (AccountActionBean), cart (CartActionBean), and order (OrderActionBean) state.
- Session attributes:
  - Stripes stores ActionBeans under path keys (e.g., "/actions/Account.action", "/actions/Cart.action").
  - Application also stores an "accountBean" attribute explicitly on successful signon (for banner/my list).
- No CSRF protection or complex auth; plaintext passwords in SIGNON table.

Caching and Performance
- MyBatis <cache/> on all mappers enables second-level cache (default settings).
- Item queries join Product (denormalized read model).
- Inventory decrements use an UPDATE operation (no explicit locking strategy beyond transaction isolation).

Couplings and Boundaries (useful for microservice decomposition)
- Account domain is coupled across three tables: ACCOUNT, PROFILE, SIGNON (+ optional BANNERDATA for display).
- Catalog domain spans CATEGORY, PRODUCT, ITEM with joins; Item views often include Product data; Inventory (INVENTORY) is a separate concern used by both Catalog (isItemInStock) and Order (stock decrement).
- Order domain spans ORDERS, ORDERSTATUS, LINEITEM; depends on Inventory (write) and Items (read) and Sequence (ID generation).
- Sequence is a shared DB concern leveraged by OrderService.
- Web layer orchestrates multi-step order flows with session state; OrderService needs both Inventory and Order-related repositories.

Configuration/Operational Notes
- Default DB is ephemeral (in-memory HSQL) seeded at startup; not suitable for persistence across restarts.
- Transactions are Spring-managed at service method level; any exception during order insert triggers rollback across inventory/order writes.
- Passwords stored in SIGNON as plaintext; no encryption/hashing; no user roles/authorization beyond simple username/password.
- Stripes tag library integrates Spring services into ActionBeans; validation annotations present only on some Account fields.

Summary of Key JSP/Page Flows
- Catalog/Main.jsp: navigation and category quick links; shows welcome text when authenticated.
- Catalog/Category.jsp: product list for category.
- Catalog/Product.jsp: item list for product; each with Add to Cart.
- Catalog/Item.jsp: item details and Add to Cart; shows in-stock vs. back-order by INVENTORY qty.
- Cart/Cart.jsp: shows cart items; allows quantity updates and item removes; proceeds to checkout.
- Cart/Checkout.jsp: read-only summary before order forms.
- Account/SignonForm.jsp: login; default values provided (j2ee/j2ee).
- Account/NewAccountForm.jsp and EditAccountForm.jsp: user/profile edit.
- Order/NewOrderForm.jsp (billing + payment), Order/ShippingForm.jsp (optional), Order/ConfirmOrder.jsp (confirmation), Order/ViewOrder.jsp (shows submitted order), Order/ListOrders.jsp (past orders).

Environment/Versioning
- Java 17 target; Jakarta servlet api 4.0 (javax to jakarta migration partially pending: spring-web fixed at 5.3.39 per POM note).
- Build reproducibility properties set; test stack with Selenide for integration testing.

This summary captures the core components, their responsibilities, the interfaces among layers, endpoints exposed by the web layer, the database schema and its relationships, transaction and caching behavior, configuration and deployment details, and significant couplings that are relevant for microservice decomposition (e.g., boundaries between Account, Catalog, Inventory, and Order domains and their shared concerns like Sequence and Inventory).

=== summary_chunk_2.txt ===

Architectural Summary (Chunk 2 of 2) — JPetStore 6 (Spring + MyBatis + Stripes)

1) High-level Architecture and Patterns
- Overall style: 3-layered MVC web application (Presentation → Service/Logic → Persistence), monolithic deployment.
- Frameworks/Patterns:
  - Presentation: Stripes MVC (ActionBeans), JSP + JSTL + Stripes tags.
  - Dependency Injection and Transactions: Spring Framework (component scan, @Service, @Autowired, @Transactional).
  - Persistence: MyBatis mappers (XML-based SQL, interfaces; no direct MyBatis API used in services).
  - Database: HSQL in-memory for dev/test via Spring EmbeddedDatabase; production could use any JDBC DataSource.
  - Caching: MyBatis second-level cache (enabled per-mapper via <cache/>).
  - Build/CI: Maven (wrapper 3.3.3; Maven 3.9.11), GitHub Actions for CI/testing/coverage/CodeQL/Sonar/Site/Deploy.
- Notable design points:
  - No direct JDBC code in services and no direct MyBatis API calls; mappers are injected; services are transaction boundaries.
  - Type aliasing to domain package simplifies mapper XML type declarations.
  - Declarative transactions (@Transactional) ensure atomicity across multiple mapper calls.
  - Data consistency: Sequence table used to generate order IDs with getNextId algorithm.

2) Components and Responsibilities
A) Presentation Layer (Stripes ActionBeans)
- org.mybatis.jpetstore.web.actions.AccountActionBean
  - Responsibilities: user sign-in/out, view/edit profile, user registration.
  - Properties observed in tests: username, password, authenticated flag, Account model, myList (null by default).
- org.mybatis.jpetstore.web.actions.CatalogActionBean
  - Responsibilities: display categories/products/items, search products, show item availability, add items to cart.
  - Methods (example from docs): viewCategory() returns a ForwardResolution to category view JSP.
  - Injects CatalogService via @SpringBean.
  - Exposes itemList, productList, categoryList, item, product, category; request params include categoryId, productId, itemId, keyword.
- org.mybatis.jpetstore.web.actions.OrderActionBean
  - Responsibilities: cart checkout, order confirmation/submission, list/view user orders.
  - Flags in tests: shippingAddressRequired, confirmed; exposes orderList.

- JSPs: Under /WEB-INF/jsp; use JSTL/Stripes tags; forms use named fields (see “Endpoints & Forms” below).

B) Service Layer (Spring @Service)
- org.mybatis.jpetstore.service.AccountService
  - APIs:
    - insertAccount(Account)
    - updateAccount(Account)
    - getAccount(String username)
    - getAccount(String username, String password)
  - Dependencies: AccountMapper (insertAccount, insertProfile, insertSignon; updateAccount, updateProfile, updateSignon; getAccountByUsername, getAccountByUsernameAndPassword).
- org.mybatis.jpetstore.service.CatalogService
  - APIs:
    - getCategoryList()
    - getCategory(String categoryId)
    - getProduct(String productId)
    - getProductListByCategory(String categoryId)
    - getItemListByProduct(String productId)
    - getItem(String itemId)
    - isItemInStock(String itemId)
    - searchProductList(String keywords)
  - Behavior: searchProductList splits keywords on whitespace, runs LIKE queries for each (“%kw%”), concatenates results.
  - Dependencies: ProductMapper, CategoryMapper, ItemMapper.
- org.mybatis.jpetstore.service.OrderService
  - APIs:
    - insertOrder(Order order) [@Transactional]
    - getOrder(int orderId) [enriches with line items and item availability]
    - getOrdersByUsername(String username)
    - getNextId(String name) [uses Sequence table]
  - Behavior (insertOrder):
    - order.setOrderId(getNextId("ordernum"))
    - For each LineItem: decrement inventory via ItemMapper.updateInventoryQuantity({itemId, increment=quantity})
    - orderMapper.insertOrder, orderMapper.insertOrderStatus
    - For each LineItem: set orderId and lineItemMapper.insertLineItem
  - Dependencies: ItemMapper, OrderMapper, LineItemMapper, SequenceMapper.
  - Business rule: getNextId throws if sequence not found; otherwise increments and persists new nextId.

C) Persistence Layer (MyBatis Mappers)
- org.mybatis.jpetstore.mapper.AccountMapper
  - Methods:
    - getAccountByUsername(String username)
    - getAccountByUsernameAndPassword(String username, String password)
    - insertAccount(Account), insertProfile(Account), insertSignon(Account)
    - updateAccount(Account), updateProfile(Account), updateSignon(Account)
  - Data: tables account, profile, signon.
- org.mybatis.jpetstore.mapper.CategoryMapper
  - Methods: getCategoryList(), getCategory(String categoryId)
  - Data: table category.
- org.mybatis.jpetstore.mapper.ProductMapper
  - Methods: getProductListByCategory(String categoryId), getProduct(String productId), searchProductList(String keywords)
  - Data: table product.
- org.mybatis.jpetstore.mapper.ItemMapper
  - Methods: getItemListByProduct(String productId), getItem(String itemId), getInventoryQuantity(String itemId), updateInventoryQuantity(Map<String,Object> {itemId, increment})
  - Data: tables item, inventory.
- org.mybatis.jpetstore.mapper.LineItemMapper
  - Methods: insertLineItem(LineItem), getLineItemsByOrderId(int orderId)
  - Data: table lineitem.
- org.mybatis.jpetstore.mapper.OrderMapper
  - Methods: getOrdersByUsername(String username), getOrder(int orderId), insertOrder(Order), insertOrderStatus(Order)
  - Data: tables orders, orderstatus.
- org.mybatis.jpetstore.mapper.SequenceMapper
  - Methods: getSequence(Sequence), updateSequence(Sequence)
  - Data: table sequence.

D) Domain Models (org.mybatis.jpetstore.domain)
- Account: username, email, firstName, lastName, status, address1, address2, city, state, zip, country, phone, languagePreference, favouriteCategoryId, listOption (boolean), bannerOption (boolean), bannerName, password.
- Category: categoryId, name, description.
- Product: productId, name, categoryId, description.
- Item: itemId, listPrice (BigDecimal), unitCost (BigDecimal), supplierId, status, attribute1..attribute5 (nullable), Product product, quantity (set from inventory when enriching).
- Cart, CartItem:
  - Cart operations: addItem(Item, inStock), removeItemById(String), containsItemId(String), getNumberOfItems(), incrementQuantityByItemId(itemId), setQuantityByItemId(itemId, qty), getSubTotal() [sum of CartItem.total], iterators getCartItems()/getAllCartItems().
  - CartItem fields: item, inStock (boolean), quantity, total (listPrice * quantity).
- Order: orderId, orderDate, username, cardType, creditCard, expiryDate, courier, locale, totalPrice, billing and shipping name/address fields, status, List<LineItem> lineItems.
  - initOrder(Account, Cart): copies account address to both ship/bill, sets defaults (creditCard="999 9999 9999 9999", cardType="Visa", expiryDate="12/03", courier="UPS", locale="CA", status="P"), totalPrice from cart.
- LineItem: orderId, lineNumber, itemId, quantity, unitPrice (BigDecimal), Item item.
- Sequence: name, nextId (int).

3) APIs, Endpoints, and UI Flows
- Servlet/Stripes Dispatch:
  - web.xml maps Stripes DispatcherServlet to URL pattern: *.action.
  - Stripes ActionBeans are auto-discovered in package: org.mybatis.jpetstore.web (via filter init param ActionResolver.Packages).
- Integration-tested UI flows (form names/links useful for API/UI contract):
  - Home page: baseUrl http://localhost:8080/jpetstore/
  - “Enter the Store” → top page (WelcomeContent empty).
  - Sign In: link “Sign In”; form fields name="username", name="password", submit name="signon"
  - Registration: link “Register Now!” → fields:
    - username, password, repeatedPassword
    - account.firstName, account.lastName, account.email, account.phone
    - account.address1, account.address2, account.city, account.state, account.zip, account.country
    - account.languagePreference (select), account.favouriteCategoryId (select [e.g., CATS])
    - account.listOption (checkbox), account.bannerOption (checkbox)
    - submit name="newAccount"
  - Search: name="keyword", submit name="searchProducts"
  - Category/Product/Item navigation via links (e.g., FI-SW-01, EST-1, etc.).
  - Cart:
    - “Add to Cart” link on item page.
    - Update quantities: input name matches itemId (e.g., name="EST-20") and submit name="updateCartQuantities".
    - Remove: delete link in cart table row.
    - Proceed to Checkout: link “Proceed to Checkout”.
  - Checkout:
    - Checkbox name="shippingAddressRequired", submit name="newOrder" to edit shipping address.
    - Confirm page: link “Confirm” to submit order.
  - Account:
    - My Account: link “My Account” shows profile, can update phone via name="account.phone" and submit name="editAccount".
  - Orders:
    - My Orders: list orders; click orderId link to details.
  - Logout: link “Sign Out”.
- Note: Exact Stripes @UrlBinding/action event methods not shown, but Actions conform to *.action mapping and follow Stripes conventions.

4) Database Schemas and Data Models (from tests and mappings)
- account:
  - Columns: USERID (PK), EMAIL, FIRSTNAME, LASTNAME, STATUS, ADDR1, ADDR2, CITY, STATE, ZIP, COUNTRY, PHONE
- profile:
  - Columns: USERID (PK, FK to account), LANGPREF, FAVCATEGORY, MYLISTOPT (0/1), BANNEROPT (0/1)
- signon:
  - Columns: USERNAME (PK), PASSWORD
- category:
  - Columns: CATID or CATEGORY (inferred as CATEGORYID), NAME, DESCN (description) [tests refer to categoryId/name/description]
- product:
  - Columns: PRODUCTID (PK), NAME, DESCN, CATEGORYID (FK to category)
- item:
  - Columns: ITEMID (PK), PRODUCTID (FK to product), LISTPRICE, UNITCOST, SUPPLIER (supplierId), STATUS, ATTR1..ATTR5
- inventory:
  - Columns: ITEMID (PK or FK), QTY
- orders:
  - Columns: ORDERID (PK), USERID, ORDERDATE (date), SHIPADDR1, SHIPADDR2, SHIPCITY, SHIPSTATE, SHIPZIP, SHIPCOUNTRY, SHIPTOFIRSTNAME, SHIPTOLASTNAME, BILLADDR1, BILLADDR2, BILLCITY, BILLSTATE, BILLZIP, BILLCOUNTRY, BILLTOFIRSTNAME, BILLTOLASTNAME, COURIER, TOTALPRICE, CREDITCARD, EXPRDATE, CARDTYPE, LOCALE
- orderstatus:
  - Columns: ORDERID (PK/FK), LINENUM (often same as orderId in inserts), TIMESTAMP (date), STATUS
- lineitem:
  - Columns: ORDERID (PK-FK), LINENUM (line number), ITEMID (FK), QUANTITY, UNITPRICE
- sequence:
  - Columns: NAME (PK), NEXTID

5) Service Dependencies and Communication Patterns
- In-process DI via Spring (no remote calls):
  - Presentation → Services: Stripes ActionBeans use @SpringBean to inject Spring-managed services.
  - Services → Persistence: Services inject MyBatis mapper interfaces (Spring MyBatis integration) and call methods directly.
  - Persistence → DB: MyBatis executes SQL from XML mappers; optional second-level cache with <cache/>.
- Transactions:
  - Spring’s DataSourceTransactionManager; transactional methods defined in services (e.g., OrderService.insertOrder()) ensure ACID behavior across multiple mapper calls.
- Cross-domain coupling notes (important for microservice decomposition):
  - OrderService depends on Item inventory adjustments (ItemMapper.updateInventoryQuantity).
  - OrderService uses SequenceMapper (global sequence table) for ID generation.
  - Order retrieval enriches line items with Item details and inventory quantity to set availability.
  - Account data spread across account, profile, signon tables requiring coordinated updates.

6) Key Business Logic and Algorithms
- Cart:
  - addItem(item, inStock): if item exists, increments quantity; sets stock flag; line total = listPrice * quantity; Cart subtotal sums line totals; supports incrementQuantityByItemId and setQuantityByItemId.
  - removeItemById(itemId) returns removed Item or null.
- OrderService.insertOrder:
  - Compute orderId via getNextId("ordernum"); for each LineItem, decrement inventory by quantity; insert order + order status; assign orderId to line items and insert.
  - Entire operation is transactional.
- OrderService.getOrder(orderId):
  - Fetch order; fetch line items; for each line item, load Item and current inventory qty; populate Item.quantity and attach to LineItem.
- OrderService.getNextId(name):
  - Fetch Sequence by name with placeholder nextId=-1; if null, throw runtime exception; else return current nextId and update sequence with nextId+1.
- CatalogService.searchProductList(keywords):
  - Split whitespace; call productMapper.searchProductList("%kw%") per token; concatenate results.
- AccountService:
  - Insert: calls insertAccount, insertProfile, insertSignon.
  - Update: calls updateAccount, updateProfile, updateSignon.
- Order.initOrder(account, cart):
  - Sets address from account to ship/bill; sets defaults: creditCard "999 9999 9999 9999", cardType "Visa", expiryDate "12/03", courier "UPS", locale "CA", status "P"; totalPrice from cart; creates line item list from cart content with consecutive line numbers.

7) Configuration and Deployment Details
- web.xml (servlet 2.5/JSP 2.1 compatible):
  - Stripes:
    - Filter: net.sourceforge.stripes.controller.StripesFilter
      - Init params:
        - ActionResolver.Packages = org.mybatis.jpetstore.web
        - Interceptor.Classes = net.sourceforge.stripes.integration.spring.SpringInterceptor (enables Spring DI into ActionBeans)
    - DispatcherServlet: net.sourceforge.stripes.controller.DispatcherServlet mapped to *.action
  - Spring:
    - ContextLoaderListener initializes Spring context (defaults to /WEB-INF/applicationContext.xml).
- applicationContext.xml (Spring):
  - <context:component-scan base-package="org.mybatis.jpetstore.service">
    - Note: mappers are not discovered by component scan; MyBatis scan is used.
  - DataSource (dev/test):
    - <jdbc:embedded-database id="dataSource"> with HSQL; scripts: classpath:database/jpetstore-hsqldb-schema.sql and -dataload.sql.
  - Transaction Manager:
    - DataSourceTransactionManager wired to DataSource.
  - MyBatis:
    - SqlSessionFactoryBean with dataSource and typeAliasesPackage="org.mybatis.jpetstore.domain".
    - <mybatis:scan base-package="org.mybatis.jpetstore.mapper"> to register mapper interfaces.
- Test configuration (MapperTestContext.java):
  - Programmatic setup equivalent to applicationContext.xml for tests; creates EmbeddedDatabase (HSQL), TransactionManager, SqlSessionFactoryBean, JdbcTemplate; @MapperScan("org.mybatis.jpetstore.mapper").
- Deployment:
  - Works on Tomcat, TomEE, WildFly, Liberty EE8, Jetty, GlassFish 5, Resin (CI “Container Support” profiles).
  - Typical context path: /jpetstore (integration tests use http://localhost:8080/jpetstore).
  - CI builds with JDK 17, 21, 24, 25-ea across OSs; CodeQL and SonarCloud integrated; site deployed to gh-pages; artifacts to Sonatype (for this example repo).

8) Communication Contracts (UI Form/Param Names and Navigation)
- Authentication:
  - POST fields: username, password; button: signon.
- Registration:
  - username, password, repeatedPassword
  - account.firstName, account.lastName, account.email, account.phone
  - account.address1, account.address2, account.city, account.state, account.zip, account.country
  - account.languagePreference (select), account.favouriteCategoryId (select)
  - account.listOption, account.bannerOption (checkbox)
  - button: newAccount
- Catalog/Search:
  - keyword; button: searchProducts; navigation via links with IDs (categories, product IDs e.g., FI-SW-01; items e.g., EST-1).
- Cart:
  - For each item line, quantity input name equals itemId (e.g., name="EST-20"); button updateCartQuantities.
  - Add to Cart link from item detail; remove link in cart row; proceed with “Proceed to Checkout”.
- Checkout:
  - shippingAddressRequired (checkbox); newOrder (button) to edit shipping; “Confirm” (link) to place order.
- Account Management:
  - account.phone; button editAccount.
- Orders:
  - “My Orders” list; each order is a link with the orderId.

9) Service and Data Ownership (for microservice decomposition considerations)
- Account domain:
  - Owns account, profile, signon tables; AccountService encapsulates operations across these tables.
- Catalog domain:
  - Owns category, product, item (and inventory) tables; CatalogService provides list/search and stock checks. ItemMapper also mutates inventory.
- Order domain:
  - Owns orders, orderstatus, lineitem tables; OrderService handles atomic creation of orders, status, and line items.
- Shared concerns:
  - Sequence service/table used for order IDs (global mutable state).
  - OrderService needs to adjust inventory (ItemMapper) during order placement—cross-domain transaction in monolith. In microservices, this coupling would require eventual consistency or an orchestration/saga.

10) Notable MyBatis Mapping Details
- OrderMapper.xml example (from docs):
  - namespace org.mybatis.jpetstore.mapper.OrderMapper
  - <cache/> enabled.
  - select getOrder joins ORDERS and ORDERSTATUS; maps column aliases to Order fields (e.g., BILLADDR1 → billAddress1, EXPRDATE → expiryDate).
- Type aliases configured for org.mybatis.jpetstore.domain, enabling short names like resultType="Order".

11) Testing and Quality
- Unit tests:
  - Domain logic (CartTest, OrderTest).
  - Service tests (AccountServiceTest, CatalogServiceTest, OrderServiceTest) via Mockito.
  - Mapper tests (AccountMapperTest, CategoryMapperTest, ItemMapperTest, LineItemMapperTest, OrderMapperTest, ProductMapperTest, SequenceMapperTest) against HSQL embedded DB and real SQL.
- Integration/UI tests:
  - ScreenTransitionIT uses Selenide, headless Chrome, exercises full user flows including login, browsing, cart, checkout, account management.

12) Project Structure (from docs)
- src/main/java/org/mybatis/jpetstore/
  - domain (domain objects)
  - mapper (mapper interfaces)
  - service (service beans)
  - web/actions (Stripes ActionBeans)
- src/main/resources/org/mybatis/jpetstore/mapper (mapper XML files)
- src/main/resources/database (SQL scripts)
- src/main/webapp/WEB-INF (web.xml, applicationContext.xml) and JSPs under WEB-INF/jsp
- CSS, images under webapp static dirs.

Key Considerations for Microservice Decomposition (based on this chunk)
- Potential service boundaries:
  - Account Service (account/profile/signon).
  - Catalog Service (category/product/item/inventory).
  - Order Service (order/orderstatus/lineitem) + ID/sequence generation.
- Couplings:
  - Order Service requires inventory decrement (Catalog/Inventory domain).
  - Shared sequence (global state) used by Order; should be owned by Order or replaced by per-service ID generation.
- Transaction scope:
  - Currently single DB transaction across orders + inventory; in microservices, would necessitate a saga/outbox or reservation pattern for stock.
- Read models:
  - Order detail enrichment fetches Item and availability; in microservices, consider denormalized projections or cross-service queries via API composition.

This summary includes component responsibilities, APIs, data models and schemas, dependencies and call paths, core business logic, configurations, deployment/testing infrastructure, and architectural patterns necessary for accurate microservice decomposition analysis.